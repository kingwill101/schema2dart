// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by json_schema2dart

class AnyOfObjects {
  final Data? data;

  const AnyOfObjects({this.data});

  factory AnyOfObjects.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = json['data'] == null
        ? null
        : Data.fromJson((json['data'] as Map).cast<String, dynamic>());
    remaining.remove('data');
    return AnyOfObjects(data: data);
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (data != null) map['data'] = data!.toJson();
    return map;
  }
}

class Text extends Data {
  final String content;

  /// Constraints: const: text
  final String type;

  const Text({required this.content, required this.type}) : super();

  factory Text.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final type = json['type'] as String;
    remaining.remove('type');
    return Text(content: content, type: type);
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    map['type'] = type;
    return map;
  }
}

class Number extends Data {
  /// Constraints: const: number
  final String type;
  final double value;

  const Number({required this.type, required this.value}) : super();

  factory Number.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final type = json['type'] as String;
    remaining.remove('type');
    final value = json['value'] as double;
    remaining.remove('value');
    return Number(type: type, value: value);
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['type'] = type;
    map['value'] = value;
    return map;
  }
}

sealed class Data {
  const Data();

  factory Data.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <Data Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'text') {
      constMatches.add(Text.fromJson);
      constMatchNames.add('Text');
    }
    if (json['type'] == 'number') {
      constMatches.add(Number.fromJson);
      constMatchNames.add('Number');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous Data variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches = <Data Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('content')) {
      requiredMatches.add(Text.fromJson);
      requiredMatchNames.add('Text');
    }
    if (keys.contains('type') && keys.contains('value')) {
      requiredMatches.add(Number.fromJson);
      requiredMatchNames.add('Number');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous Data variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No Data variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  Map<String, dynamic> toJson();
}
