// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by json_schema2dart

class AnyOfObjects {
  final AnyOfObjectsData? data;

  const AnyOfObjects({
    this.data,
  });

  factory AnyOfObjects.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = json['data'] == null ? null : AnyOfObjectsData.fromJson((json['data'] as Map).cast<String, dynamic>());
    remaining.remove('data');
    return AnyOfObjects(
      data: data,
    );
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (data != null) map['data'] = data!.toJson();
    return map;
  }
}

class Data extends AnyOfObjectsData {
  final String content;
  /// Constraints: const: text
  final String type;

  const Data({
    required this.content,
    required this.type,
  }) : super();

  factory Data.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final type = json['type'] as String;
    remaining.remove('type');
    return Data(
      content: content,
      type: type,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    map['type'] = type;
    return map;
  }
}

class Data2 extends AnyOfObjectsData {
  /// Constraints: const: number
  final String type;
  final double value;

  const Data2({
    required this.type,
    required this.value,
  }) : super();

  factory Data2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final type = json['type'] as String;
    remaining.remove('type');
    final value = json['value'] as double;
    remaining.remove('value');
    return Data2(
      type: type,
      value: value,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['type'] = type;
    map['value'] = value;
    return map;
  }
}

sealed class AnyOfObjectsData {
  const AnyOfObjectsData();

  factory AnyOfObjectsData.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <AnyOfObjectsData Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'text') {
      constMatches.add(Data.fromJson);
      constMatchNames.add('Data');
    }
    if (json['type'] == 'number') {
      constMatches.add(Data2.fromJson);
      constMatchNames.add('Data2');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError('Ambiguous AnyOfObjectsData variant matched const heuristics: ${constMatchNames.join(', ')}');
    }
    final requiredMatches = <AnyOfObjectsData Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('content')) {
      requiredMatches.add(Data.fromJson);
      requiredMatchNames.add('Data');
    }
    if (keys.contains('type') && keys.contains('value')) {
      requiredMatches.add(Data2.fromJson);
      requiredMatchNames.add('Data2');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError('Ambiguous AnyOfObjectsData variant matched required-property heuristics: ${requiredMatchNames.join(', ')}');
    }
    throw ArgumentError('No AnyOfObjectsData variant matched heuristics (keys: ${sortedKeys.join(', ')}).');
  }

  Map<String, dynamic> toJson();
}
