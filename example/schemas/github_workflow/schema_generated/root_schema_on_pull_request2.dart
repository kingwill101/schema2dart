// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'types.dart';
import 'validation_error.dart';

class RootSchemaOnPullRequest2 {
  final List<String>? branches;
  final List<String>? branchesIgnore;
  final List<String>? paths;
  final List<String>? pathsIgnore;
  final List<String>? tags;
  final List<String>? tagsIgnore;

  /// Default: [opened, synchronize, reopened].
  final Types? types;

  const RootSchemaOnPullRequest2({
    this.branches,
    this.branchesIgnore,
    this.paths,
    this.pathsIgnore,
    this.tags,
    this.tagsIgnore,
    this.types = const TypesArray(const ['opened', 'synchronize', 'reopened']),
  });

  factory RootSchemaOnPullRequest2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final branches = json['branches'] == null
        ? null
        : (json['branches'] as List).map((e) => e as String).toList();
    remaining.remove('branches');
    final branchesIgnore = json['branches-ignore'] == null
        ? null
        : (json['branches-ignore'] as List).map((e) => e as String).toList();
    remaining.remove('branches-ignore');
    final paths = json['paths'] == null
        ? null
        : (json['paths'] as List).map((e) => e as String).toList();
    remaining.remove('paths');
    final pathsIgnore = json['paths-ignore'] == null
        ? null
        : (json['paths-ignore'] as List).map((e) => e as String).toList();
    remaining.remove('paths-ignore');
    final tags = json['tags'] == null
        ? null
        : (json['tags'] as List).map((e) => e as String).toList();
    remaining.remove('tags');
    final tagsIgnore = json['tags-ignore'] == null
        ? null
        : (json['tags-ignore'] as List).map((e) => e as String).toList();
    remaining.remove('tags-ignore');
    final types =
        (json['types'] == null
            ? null
            : Types.fromJson((json['types'] as Map).cast<String, dynamic>())) ??
        const TypesArray(const ['opened', 'synchronize', 'reopened']);
    remaining.remove('types');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return RootSchemaOnPullRequest2(
      branches: branches,
      branchesIgnore: branchesIgnore,
      paths: paths,
      pathsIgnore: pathsIgnore,
      tags: tags,
      tagsIgnore: tagsIgnore,
      types: types,
    );
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (branches != null) map['branches'] = branches;
    if (branchesIgnore != null) map['branches-ignore'] = branchesIgnore;
    if (paths != null) map['paths'] = paths;
    if (pathsIgnore != null) map['paths-ignore'] = pathsIgnore;
    if (tags != null) map['tags'] = tags;
    if (tagsIgnore != null) map['tags-ignore'] = tagsIgnore;
    if (types != null) map['types'] = types!.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'branches');
    final _value0 = branches;
    if (_value0 != null) {
      context?.markProperty(pointer, 'branches');
      final _lenp0 = _value0.length;
      final _evaluatedp0 = List<bool>.filled(_lenp0, false);
      for (var i = 0; i < _lenp0; i++) {
        final itemPointer = appendJsonPointer(_ptr0, i.toString());
        final item = _value0[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp0[i] = true;
        context?.markItem(_ptr0, i);
      }
    }
    final _ptr1 = appendJsonPointer(pointer, 'branches-ignore');
    final _value1 = branchesIgnore;
    if (_value1 != null) {
      context?.markProperty(pointer, 'branches-ignore');
      final _lenp1 = _value1.length;
      final _evaluatedp1 = List<bool>.filled(_lenp1, false);
      for (var i = 0; i < _lenp1; i++) {
        final itemPointer = appendJsonPointer(_ptr1, i.toString());
        final item = _value1[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp1[i] = true;
        context?.markItem(_ptr1, i);
      }
    }
    final _ptr2 = appendJsonPointer(pointer, 'paths');
    final _value2 = paths;
    if (_value2 != null) {
      context?.markProperty(pointer, 'paths');
      final _lenp2 = _value2.length;
      final _evaluatedp2 = List<bool>.filled(_lenp2, false);
      for (var i = 0; i < _lenp2; i++) {
        final itemPointer = appendJsonPointer(_ptr2, i.toString());
        final item = _value2[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp2[i] = true;
        context?.markItem(_ptr2, i);
      }
    }
    final _ptr3 = appendJsonPointer(pointer, 'paths-ignore');
    final _value3 = pathsIgnore;
    if (_value3 != null) {
      context?.markProperty(pointer, 'paths-ignore');
      final _lenp3 = _value3.length;
      final _evaluatedp3 = List<bool>.filled(_lenp3, false);
      for (var i = 0; i < _lenp3; i++) {
        final itemPointer = appendJsonPointer(_ptr3, i.toString());
        final item = _value3[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp3[i] = true;
        context?.markItem(_ptr3, i);
      }
    }
    final _ptr4 = appendJsonPointer(pointer, 'tags');
    final _value4 = tags;
    if (_value4 != null) {
      context?.markProperty(pointer, 'tags');
      final _lenp4 = _value4.length;
      final _evaluatedp4 = List<bool>.filled(_lenp4, false);
      for (var i = 0; i < _lenp4; i++) {
        final itemPointer = appendJsonPointer(_ptr4, i.toString());
        final item = _value4[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp4[i] = true;
        context?.markItem(_ptr4, i);
      }
    }
    final _ptr5 = appendJsonPointer(pointer, 'tags-ignore');
    final _value5 = tagsIgnore;
    if (_value5 != null) {
      context?.markProperty(pointer, 'tags-ignore');
      final _lenp5 = _value5.length;
      final _evaluatedp5 = List<bool>.filled(_lenp5, false);
      for (var i = 0; i < _lenp5; i++) {
        final itemPointer = appendJsonPointer(_ptr5, i.toString());
        final item = _value5[i];
        if (item.length < 1) {
          throwValidationError(
            itemPointer,
            'minLength',
            'Expected at least 1 characters but found ' +
                item.length.toString() +
                '.',
          );
        }
        _evaluatedp5[i] = true;
        context?.markItem(_ptr5, i);
      }
    }
    final _ptr6 = appendJsonPointer(pointer, 'types');
    final _value6 = types;
    context?.annotate(
      _ptr6,
      'default',
      '[opened, synchronize, reopened]',
      schemaPointer:
          '#/properties/on/oneOf/2/properties/pull_request/oneOf/1/allOf/0/properties/types',
    );
    if (_value6 != null) {
      context?.markProperty(pointer, 'types');
    }
  }
}
