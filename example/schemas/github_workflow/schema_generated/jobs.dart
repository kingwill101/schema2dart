// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'jobs_pattern_property1.dart';
import 'validation_error.dart';

/// A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
/// Each job runs in a fresh instance of the virtual environment specified by runs-on.
/// You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
class Jobs {
  final Map<String, JobsPatternProperty1>? patternProperties;

  const Jobs({this.patternProperties});

  factory Jobs.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    var unmatched = Map<String, dynamic>.from(remaining);
    Map<String, JobsPatternProperty1>? patternPropertiesValue;
    {
      final patternPropertiesMap = <String, JobsPatternProperty1>{};
      final unmatchedAfterPattern = <String, dynamic>{};
      for (final entry in unmatched.entries) {
        final key = entry.key;
        final value = entry.value;
        var matched = false;
        if (!matched && RegExp('^[_a-zA-Z][a-zA-Z0-9_-]*\$').hasMatch(key)) {
          patternPropertiesMap[key] = JobsPatternProperty1.fromJson(
            (value as Map).cast<String, dynamic>(),
          );
          matched = true;
        }
        if (!matched) {
          unmatchedAfterPattern[key] = value;
        }
      }
      patternPropertiesValue = patternPropertiesMap.isEmpty
          ? null
          : patternPropertiesMap;
      unmatched = unmatchedAfterPattern;
    }
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Jobs(patternProperties: patternPropertiesValue);
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (patternProperties != null) {
      for (final entry in patternProperties!.entries) {
        final key = entry.key;
        final value = entry.value;
        var matched = false;
        if (!matched && RegExp('^[_a-zA-Z][a-zA-Z0-9_-]*\$').hasMatch(key)) {
          map[key] = value.toJson();
          matched = true;
        }
        if (!matched) {
          map[key] = value;
        }
      }
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final _patternPropertiesMap = patternProperties;
    if (_patternPropertiesMap != null) {
      _patternPropertiesMap.forEach((key, value) {
        final itemPointer = appendJsonPointer(pointer, key);
        context?.markProperty(pointer, key);
        final _jsonpatternProperties = value.toJson();
        final _constraintpatternPropertiesc0_0 = context == null
            ? null
            : ValidationContext();
        var _constraintpatternPropertiesm0_0 = false;
        try {
          final context = _constraintpatternPropertiesc0_0;
          final _constraintpatternPropertiesv0_0 = NormalJob.fromJson(
            (_jsonpatternProperties as Map).cast<String, dynamic>(),
          );
          _constraintpatternPropertiesv0_0.validate(
            pointer: itemPointer,
            context: context,
          );
          _constraintpatternPropertiesm0_0 = true;
        } on ValidationError {
        } catch (_) {}
        final _constraintpatternPropertiesc0_1 = context == null
            ? null
            : ValidationContext();
        var _constraintpatternPropertiesm0_1 = false;
        try {
          final context = _constraintpatternPropertiesc0_1;
          final _constraintpatternPropertiesv0_1 =
              ReusableWorkflowCallJob.fromJson(
                (_jsonpatternProperties as Map).cast<String, dynamic>(),
              );
          _constraintpatternPropertiesv0_1.validate(
            pointer: itemPointer,
            context: context,
          );
          _constraintpatternPropertiesm0_1 = true;
        } on ValidationError {
        } catch (_) {}
        final _constraintpatternPropertiesmatches0 = <bool>[
          _constraintpatternPropertiesm0_0,
          _constraintpatternPropertiesm0_1,
        ];
        final _constraintpatternPropertiescount0 =
            _constraintpatternPropertiesmatches0.where((value) => value).length;
        if (_constraintpatternPropertiescount0 != 1) {
          throwValidationError(
            itemPointer,
            'oneOf',
            'Expected exactly one subschema in #/properties/jobs/patternProperties/^[_a-zA-Z][a-zA-Z0-9_-]*\$/oneOf to validate.',
          );
        }
        if (context != null &&
            _constraintpatternPropertiesm0_0 &&
            _constraintpatternPropertiesc0_0 != null) {
          context.mergeFrom(_constraintpatternPropertiesc0_0!);
        }
        if (context != null &&
            _constraintpatternPropertiesm0_1 &&
            _constraintpatternPropertiesc0_1 != null) {
          context.mergeFrom(_constraintpatternPropertiesc0_1!);
        }
      });
    }
  }
}
