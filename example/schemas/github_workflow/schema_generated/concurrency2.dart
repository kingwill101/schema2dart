// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'concurrency_cancel_in_progress.dart';
import 'validation_error.dart';

/// Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context.
/// You can also specify concurrency at the workflow level.
/// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
sealed class Concurrency2 {
  const Concurrency2();

  void validate({String pointer = '', ValidationContext? context});

  factory Concurrency2.fromJson(dynamic json) {
    if (json is String) return Concurrency2String(json);
    if (json is! Map<String, dynamic>) {
      throw ArgumentError('Invalid Concurrency2 value: ${json.runtimeType}');
    }
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final requiredMatches = <Concurrency2 Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('group')) {
      requiredMatches.add(Concurrency2Concurrency.fromJson);
      requiredMatchNames.add('Concurrency2Concurrency');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous Concurrency2 variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    return Concurrency2Concurrency.fromJson(json);
  }

  dynamic toJson();
}

class Concurrency2String extends Concurrency2 {
  final String value;

  const Concurrency2String(this.value) : super();

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class Concurrency2Concurrency extends Concurrency2 {
  /// To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  final ConcurrencyCancelInProgress? cancelInProgress;

  /// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
  final String group;

  const Concurrency2Concurrency({this.cancelInProgress, required this.group})
    : super();

  factory Concurrency2Concurrency.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final cancelInProgress = json['cancel-in-progress'] == null
        ? null
        : ConcurrencyCancelInProgress.fromJson(
            (json['cancel-in-progress'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('cancel-in-progress');
    final group = json['group'] as String;
    remaining.remove('group');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Concurrency2Concurrency(
      cancelInProgress: cancelInProgress,
      group: group,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (cancelInProgress != null)
      map['cancel-in-progress'] = cancelInProgress!.toJson();
    map['group'] = group;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'cancel-in-progress');
    final _value0 = cancelInProgress;
    if (_value0 != null) {
      context?.markProperty(pointer, 'cancel-in-progress');
      final _jsonp0 = _value0.toJson();
      final _constraintp0c0_0 = context == null ? null : ValidationContext();
      var _constraintp0m0_0 = false;
      try {
        final context = _constraintp0c0_0;
        final _constraintp0v0_0 = _jsonp0 as bool;
        _constraintp0m0_0 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0c0_1 = context == null ? null : ValidationContext();
      var _constraintp0m0_1 = false;
      try {
        final context = _constraintp0c0_1;
        final _constraintp0v0_1 = _jsonp0 as String;
        _constraintp0m0_1 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0matches0 = <bool>[
        _constraintp0m0_0,
        _constraintp0m0_1,
      ];
      final _constraintp0count0 = _constraintp0matches0
          .where((value) => value)
          .length;
      if (_constraintp0count0 != 1) {
        throwValidationError(
          _ptr0,
          'oneOf',
          'Expected exactly one subschema in #/definitions/concurrency/properties/cancel-in-progress/oneOf to validate.',
        );
      }
      if (context != null && _constraintp0m0_0 && _constraintp0c0_0 != null) {
        context.mergeFrom(_constraintp0c0_0!);
      }
      if (context != null && _constraintp0m0_1 && _constraintp0c0_1 != null) {
        context.mergeFrom(_constraintp0c0_1!);
      }
    }
    final _ptr1 = appendJsonPointer(pointer, 'group');
    final _value1 = group;
    context?.markProperty(pointer, 'group');
  }
}
