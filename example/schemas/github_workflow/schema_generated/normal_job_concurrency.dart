// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'concurrency_cancel_in_progress.dart';
import 'validation_error.dart';

/// Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context.
/// You can also specify concurrency at the workflow level.
/// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
sealed class NormalJobConcurrency {
  const NormalJobConcurrency();

  void validate({String pointer = '', ValidationContext? context});

  factory NormalJobConcurrency.fromJson(dynamic json) {
    if (json is String) return NormalJobConcurrencyString(json);
    if (json is! Map<String, dynamic>) {
      throw ArgumentError('Invalid NormalJobConcurrency value: ${json.runtimeType}');
    }
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final requiredMatches = <NormalJobConcurrency Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('group')) {
      requiredMatches.add(NormalJobConcurrencyObject.fromJson);
      requiredMatchNames.add('NormalJobConcurrencyObject');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError('Ambiguous NormalJobConcurrency variant matched required-property heuristics: ${requiredMatchNames.join(', ')}');
    }
    return NormalJobConcurrencyObject.fromJson(json);
  }

  dynamic toJson();
}
class NormalJobConcurrencyString extends NormalJobConcurrency {
  final String value;

  const NormalJobConcurrencyString(this.value) : super();

  @override
  dynamic toJson() => value;
}
class NormalJobConcurrencyObject extends NormalJobConcurrency {
  /// To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  final ConcurrencyCancelInProgress? cancelInProgress;
  /// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
  final String group;

  const NormalJobConcurrencyObject({
    this.cancelInProgress,
    required this.group,
  }) : super();

  factory NormalJobConcurrencyObject.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final cancelInProgress = json['cancel-in-progress'] == null ? null : ConcurrencyCancelInProgress.fromJson((json['cancel-in-progress'] as Map).cast<String, dynamic>());
    remaining.remove('cancel-in-progress');
    final group = json['group'] as String;
    remaining.remove('group');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return NormalJobConcurrencyObject(
      cancelInProgress: cancelInProgress,
      group: group,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (cancelInProgress != null) map['cancel-in-progress'] = cancelInProgress!.toJson();
    map['group'] = group;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}
