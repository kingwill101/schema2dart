// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'concurrency2.dart';
import 'defaults.dart';
import 'env.dart';
import 'jobs.dart';
import 'on.dart';
import 'permissions.dart';
import 'validation_error.dart';

class GithubWorkflow {
  /// Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context.
  /// You can also specify concurrency at the workflow level.
  /// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  final Concurrency2? concurrency;

  /// A map of default settings that will apply to all jobs in the workflow.
  final Defaults? defaults;

  /// A map of environment variables that are available to all jobs and steps in the workflow.
  final Env? env;

  /// A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
  /// Each job runs in a fresh instance of the virtual environment specified by runs-on.
  /// You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
  /// Constraints: minProperties: 1
  final Jobs jobs;

  /// The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
  final String? name;

  /// The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.
  final On on_;
  final Permissions? permissions;

  /// The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's 'Actions' tab.
  final String? runName;

  const GithubWorkflow({
    this.concurrency,
    this.defaults,
    this.env,
    required this.jobs,
    this.name,
    required this.on_,
    this.permissions,
    this.runName,
  });

  factory GithubWorkflow.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final concurrency = json['concurrency'] == null
        ? null
        : Concurrency2.fromJson(
            (json['concurrency'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('concurrency');
    final defaults = json['defaults'] == null
        ? null
        : Defaults.fromJson((json['defaults'] as Map).cast<String, dynamic>());
    remaining.remove('defaults');
    final env = json['env'] == null
        ? null
        : Env.fromJson((json['env'] as Map).cast<String, dynamic>());
    remaining.remove('env');
    final jobs = Jobs.fromJson((json['jobs'] as Map).cast<String, dynamic>());
    remaining.remove('jobs');
    final name = json['name'] as String?;
    remaining.remove('name');
    final on_ = On.fromJson((json['on'] as Map).cast<String, dynamic>());
    remaining.remove('on');
    final permissions = json['permissions'] == null
        ? null
        : Permissions.fromJson(
            (json['permissions'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('permissions');
    final runName = json['run-name'] as String?;
    remaining.remove('run-name');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return GithubWorkflow(
      concurrency: concurrency,
      defaults: defaults,
      env: env,
      jobs: jobs,
      name: name,
      on_: on_,
      permissions: permissions,
      runName: runName,
    );
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (concurrency != null) map['concurrency'] = concurrency!.toJson();
    if (defaults != null) map['defaults'] = defaults!.toJson();
    if (env != null) map['env'] = env!.toJson();
    map['jobs'] = jobs.toJson();
    if (name != null) map['name'] = name;
    map['on'] = on_.toJson();
    if (permissions != null) map['permissions'] = permissions!.toJson();
    if (runName != null) map['run-name'] = runName;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'concurrency');
    final _value0 = concurrency;
    if (_value0 != null) {
      context?.markProperty(pointer, 'concurrency');
      final _jsonp0 = _value0.toJson();
      final _constraintp0c0_0 = context == null ? null : ValidationContext();
      var _constraintp0m0_0 = false;
      try {
        final context = _constraintp0c0_0;
        final _constraintp0v0_0 = _jsonp0 as String;
        _constraintp0m0_0 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0c0_1 = context == null ? null : ValidationContext();
      var _constraintp0m0_1 = false;
      try {
        final context = _constraintp0c0_1;
        final _constraintp0v0_1 = Concurrency.fromJson(
          (_jsonp0 as Map).cast<String, dynamic>(),
        );
        _constraintp0v0_1.validate(pointer: _ptr0, context: context);
        _constraintp0m0_1 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0matches0 = <bool>[
        _constraintp0m0_0,
        _constraintp0m0_1,
      ];
      final _constraintp0count0 = _constraintp0matches0
          .where((value) => value)
          .length;
      if (_constraintp0count0 != 1) {
        throwValidationError(
          _ptr0,
          'oneOf',
          'Expected exactly one subschema in #/properties/concurrency/oneOf to validate.',
        );
      }
      if (context != null && _constraintp0m0_0 && _constraintp0c0_0 != null) {
        context.mergeFrom(_constraintp0c0_0!);
      }
      if (context != null && _constraintp0m0_1 && _constraintp0c0_1 != null) {
        context.mergeFrom(_constraintp0c0_1!);
      }
    }
    final _ptr1 = appendJsonPointer(pointer, 'defaults');
    final _value1 = defaults;
    if (_value1 != null) {
      context?.markProperty(pointer, 'defaults');
      _value1.validate(pointer: _ptr1, context: context);
    }
    final _ptr2 = appendJsonPointer(pointer, 'env');
    final _value2 = env;
    if (_value2 != null) {
      context?.markProperty(pointer, 'env');
    }
    final _ptr3 = appendJsonPointer(pointer, 'jobs');
    final _value3 = jobs;
    context?.markProperty(pointer, 'jobs');
    final _propertyCountp3 = _value3.toJson().length;
    if (_propertyCountp3 < 1) {
      throwValidationError(
        _ptr3,
        'minProperties',
        'Expected at least 1 properties but found ' +
            _propertyCountp3.toString() +
            '.',
      );
    }
    _value3.validate(pointer: _ptr3, context: context);
    final _ptr4 = appendJsonPointer(pointer, 'name');
    final _value4 = name;
    if (_value4 != null) {
      context?.markProperty(pointer, 'name');
    }
    final _ptr5 = appendJsonPointer(pointer, 'on');
    final _value5 = on_;
    context?.markProperty(pointer, 'on');
    final _jsonp5 = _value5.toJson();
    final _constraintp5c0_0 = context == null ? null : ValidationContext();
    var _constraintp5m0_0 = false;
    try {
      final context = _constraintp5c0_0;
      final _constraintp5v0_0 = EventJson.fromJson(_jsonp5 as String);
      _constraintp5m0_0 = true;
    } on ValidationError {
    } catch (_) {}
    final _constraintp5c0_1 = context == null ? null : ValidationContext();
    var _constraintp5m0_1 = false;
    try {
      final context = _constraintp5c0_1;
      final _constraintp5v0_1 = (_jsonp5 as List)
          .map((e) => EventJson.fromJson(e as String))
          .toList();
      if (_constraintp5v0_1.length < 1) {
        throwValidationError(
          _ptr5,
          'minItems',
          'Expected at least 1 items but found ' +
              _constraintp5v0_1.length.toString() +
              '.',
        );
      }
      _constraintp5m0_1 = true;
    } on ValidationError {
    } catch (_) {}
    final _constraintp5c0_2 = context == null ? null : ValidationContext();
    var _constraintp5m0_2 = false;
    try {
      final context = _constraintp5c0_2;
      final _constraintp5v0_2 = OnObject.fromJson(
        (_jsonp5 as Map).cast<String, dynamic>(),
      );
      _constraintp5v0_2.validate(pointer: _ptr5, context: context);
      _constraintp5m0_2 = true;
    } on ValidationError {
    } catch (_) {}
    final _constraintp5matches0 = <bool>[
      _constraintp5m0_0,
      _constraintp5m0_1,
      _constraintp5m0_2,
    ];
    final _constraintp5count0 = _constraintp5matches0
        .where((value) => value)
        .length;
    if (_constraintp5count0 != 1) {
      throwValidationError(
        _ptr5,
        'oneOf',
        'Expected exactly one subschema in #/properties/on/oneOf to validate.',
      );
    }
    if (context != null && _constraintp5m0_0 && _constraintp5c0_0 != null) {
      context.mergeFrom(_constraintp5c0_0!);
    }
    if (context != null && _constraintp5m0_1 && _constraintp5c0_1 != null) {
      context.mergeFrom(_constraintp5c0_1!);
    }
    if (context != null && _constraintp5m0_2 && _constraintp5c0_2 != null) {
      context.mergeFrom(_constraintp5c0_2!);
    }
    final _ptr6 = appendJsonPointer(pointer, 'permissions');
    final _value6 = permissions;
    if (_value6 != null) {
      context?.markProperty(pointer, 'permissions');
    }
    final _ptr7 = appendJsonPointer(pointer, 'run-name');
    final _value7 = runName;
    if (_value7 != null) {
      context?.markProperty(pointer, 'run-name');
    }
  }
}
