// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'container_credentials.dart';
import 'container_port.dart';
import 'reusable_workflow_call_job_secrets.dart';

/// A container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.
/// If you do not set a container, all steps will run directly on the host specified by runs-on unless a step refers to an action configured to run in a container.
sealed class NormalJobContainer {
  const NormalJobContainer();

  factory NormalJobContainer.fromJson(dynamic json) {
    if (json is String) return NormalJobContainerString(json);
    if (json is! Map<String, dynamic>) {
      throw ArgumentError('Invalid NormalJobContainer value: ${json.runtimeType}');
    }
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final requiredMatches = <NormalJobContainer Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('image')) {
      requiredMatches.add(Container.fromJson);
      requiredMatchNames.add('Container');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError('Ambiguous NormalJobContainer variant matched required-property heuristics: ${requiredMatchNames.join(', ')}');
    }
    return Container.fromJson(json);
  }

  dynamic toJson();
}
class NormalJobContainerString extends NormalJobContainer {
  final String value;

  const NormalJobContainerString(this.value) : super();

  @override
  dynamic toJson() => value;
}
class Container extends NormalJobContainer {
  /// If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.
  final ContainerCredentials? credentials;
  /// Sets an array of environment variables in the container.
  final ContainerEnv? env;
  /// The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
  final String image;
  /// Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.
  final String? options;
  /// Sets an array of ports to expose on the container.
  /// Constraints: minItems: 1
  final List<ContainerPort>? ports;
  /// Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
  /// To specify a volume, you specify the source and destination path: <source>:<destinationPath>
  /// The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
  /// Constraints: minItems: 1
  final List<String>? volumes;

  const Container({
    this.credentials,
    this.env,
    required this.image,
    this.options,
    this.ports,
    this.volumes,
  }) : super();

  factory Container.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final credentials = json['credentials'] == null ? null : ContainerCredentials.fromJson((json['credentials'] as Map).cast<String, dynamic>());
    remaining.remove('credentials');
    final env = json['env'] == null ? null : ContainerEnv.fromJson((json['env'] as Map).cast<String, dynamic>());
    remaining.remove('env');
    final image = json['image'] as String;
    remaining.remove('image');
    final options = json['options'] as String?;
    remaining.remove('options');
    final ports = json['ports'] == null ? null : (json['ports'] as List).map((e) => ContainerPort.fromJson((e as Map).cast<String, dynamic>())).toList();
    remaining.remove('ports');
    final volumes = json['volumes'] == null ? null : (json['volumes'] as List).map((e) => e as String).toList();
    remaining.remove('volumes');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Container(
      credentials: credentials,
      env: env,
      image: image,
      options: options,
      ports: ports,
      volumes: volumes,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (credentials != null) map['credentials'] = credentials!.toJson();
    if (env != null) map['env'] = env!.toJson();
    map['image'] = image;
    if (options != null) map['options'] = options;
    if (ports != null) map['ports'] = ports!.map((e) => e.toJson()).toList();
    if (volumes != null) map['volumes'] = volumes;
    return map;
  }
}
