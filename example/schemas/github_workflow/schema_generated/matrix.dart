// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_workflow/schema.json
// Generated by json_schema2dart

import 'matrix_object_additional_property.dart';
import 'matrix_object_pattern_property1.dart';
import 'validation_error.dart';

/// A build matrix is a set of different configurations of the virtual environment. For example you might run a job against more than one supported version of a language, operating system, or tool. Each configuration is a copy of the job that runs and reports a status.
/// You can specify a matrix by supplying an array for the configuration options. For example, if the GitHub virtual environment supports Node.js versions 6, 8, and 10 you could specify an array of those versions in the matrix.
/// When you define a matrix of operating systems, you must set the required runs-on keyword to the operating system of the current job, rather than hard-coding the operating system name. To access the operating system name, you can use the matrix.os context parameter to set runs-on. For more information, see https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions.
sealed class Matrix {
  const Matrix();

  void validate({String pointer = '', ValidationContext? context});

  factory Matrix.fromJson(dynamic json) {
    if (json is String) return MatrixString(json);
    if (json is! Map<String, dynamic>) {
      throw ArgumentError('Invalid Matrix value: ${json.runtimeType}');
    }
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    return MatrixObject.fromJson(json);
  }

  dynamic toJson();
}
class MatrixObject extends Matrix {
  final Map<String, MatrixObjectPatternProperty1>? patternProperties;
  final Map<String, MatrixObjectAdditionalProperty>? additionalProperties;

  const MatrixObject({
    this.patternProperties,
    this.additionalProperties,
  }) : super();

  factory MatrixObject.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    var unmatched = Map<String, dynamic>.from(remaining);
    Map<String, MatrixObjectPatternProperty1>? patternPropertiesValue;
    {
      final patternPropertiesMap = <String, MatrixObjectPatternProperty1>{};
      final unmatchedAfterPattern = <String, dynamic>{};
      for (final entry in unmatched.entries) {
        final key = entry.key;
        final value = entry.value;
        var matched = false;
        if (!matched && RegExp('^(in|ex)clude\$').hasMatch(key)) {
          patternPropertiesMap[key] = MatrixObjectPatternProperty1.fromJson((value as Map).cast<String, dynamic>());
          matched = true;
        }
        if (!matched) {
          unmatchedAfterPattern[key] = value;
        }
      }
      patternPropertiesValue = patternPropertiesMap.isEmpty ? null : patternPropertiesMap;
      unmatched = unmatchedAfterPattern;
    }
    Map<String, MatrixObjectAdditionalProperty>? additionalPropertiesValue;
    if (unmatched.isNotEmpty) {
      final additionalPropertiesMap = <String, MatrixObjectAdditionalProperty>{};
      for (final entry in unmatched.entries) {
        final value = entry.value;
        additionalPropertiesMap[entry.key] = MatrixObjectAdditionalProperty.fromJson((value as Map).cast<String, dynamic>());
      }
      additionalPropertiesValue = additionalPropertiesMap.isEmpty ? null : additionalPropertiesMap;
      unmatched = <String, dynamic>{};
    } else {
      additionalPropertiesValue = null;
    }
    return MatrixObject(
      patternProperties: patternPropertiesValue,
      additionalProperties: additionalPropertiesValue,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (patternProperties != null) {
      for (final entry in patternProperties!.entries) {
        final key = entry.key;
        final value = entry.value;
        var matched = false;
        if (!matched && RegExp('^(in|ex)clude\$').hasMatch(key)) {
          map[key] = value.toJson();
          matched = true;
        }
        if (!matched) {
          map[key] = value;
        }
      }
    }
    if (additionalProperties != null) {
      additionalProperties!.forEach((key, value) {
        map[key] = value.toJson();
      });
    }
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}
class MatrixString extends Matrix {
  final String value;

  const MatrixString(this.value) : super();

  @override
  dynamic toJson() => value;
}
