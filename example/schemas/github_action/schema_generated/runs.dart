// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/github_action/schema.json
// Generated by json_schema2dart

import 'runs_composite_step.dart';
import 'runs_docker_env.dart';
import 'runs_javascript_using.dart';
import 'validation_error.dart';

sealed class Runs {
  const Runs();

  void validate({String pointer = '', ValidationContext? context});

  factory Runs.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <Runs Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['using'] == 'composite') {
      constMatches.add(RunsComposite.fromJson);
      constMatchNames.add('RunsComposite');
    }
    if (json['using'] == 'docker') {
      constMatches.add(RunsDocker.fromJson);
      constMatchNames.add('RunsDocker');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous Runs variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches = <Runs Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('using') && keys.contains('main')) {
      requiredMatches.add(RunsJavascript.fromJson);
      requiredMatchNames.add('RunsJavascript');
    }
    if (keys.contains('using') && keys.contains('steps')) {
      requiredMatches.add(RunsComposite.fromJson);
      requiredMatchNames.add('RunsComposite');
    }
    if (keys.contains('using') && keys.contains('image')) {
      requiredMatches.add(RunsDocker.fromJson);
      requiredMatchNames.add('RunsDocker');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous Runs variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No Runs variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  Map<String, dynamic> toJson();
}

/// Configures the path to the action's code and the application used to execute the code.
class RunsJavascript extends Runs {
  /// The file that contains your action code. The application specified in `using` executes this file.
  final String main;

  /// Allows you to run a script at the end of a job, once the `main:` action has completed. For example, you can use `post:` to terminate certain processes or remove unneeded files. The application specified with the `using` syntax will execute this file. The `post:` action always runs by default but you can override this using `post-if`.
  final String? post;
  final String? postIf;

  /// Allows you to run a script at the start of a job, before the `main:` action begins. For example, you can use `pre:` to run a prerequisite setup script. The application specified with the `using` syntax will execute this file. The `pre:` action always runs by default but you can override this using `pre-if`.
  final String? pre;
  final String? preIf;

  /// The application used to execute the code specified in `main`.
  final RunsJavascriptUsing using;

  const RunsJavascript({
    required this.main,
    this.post,
    this.postIf,
    this.pre,
    this.preIf,
    required this.using,
  }) : super();

  factory RunsJavascript.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final main = json['main'] as String;
    remaining.remove('main');
    final post = json['post'] as String?;
    remaining.remove('post');
    final postIf = json['post-if'] as String?;
    remaining.remove('post-if');
    final pre = json['pre'] as String?;
    remaining.remove('pre');
    final preIf = json['pre-if'] as String?;
    remaining.remove('pre-if');
    final using = RunsJavascriptUsingJson.fromJson(json['using'] as String);
    remaining.remove('using');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return RunsJavascript(
      main: main,
      post: post,
      postIf: postIf,
      pre: pre,
      preIf: preIf,
      using: using,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['main'] = main;
    if (post != null) map['post'] = post;
    if (postIf != null) map['post-if'] = postIf;
    if (pre != null) map['pre'] = pre;
    if (preIf != null) map['pre-if'] = preIf;
    map['using'] = using.toJson();
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

/// Configures the path to the composite action, and the application used to execute the code.
class RunsComposite extends Runs {
  /// The run steps that you plan to run in this action.
  final List<RunsCompositeStep> steps;

  /// To use a composite run steps action, set this to 'composite'.
  /// Constraints: const: composite
  final String using;

  const RunsComposite({required this.steps, required this.using}) : super();

  factory RunsComposite.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final steps = (json['steps'] as List)
        .map(
          (e) => RunsCompositeStep.fromJson((e as Map).cast<String, dynamic>()),
        )
        .toList();
    remaining.remove('steps');
    final using = json['using'] as String;
    remaining.remove('using');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return RunsComposite(steps: steps, using: using);
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['steps'] = steps.map((e) => e.toJson()).toList();
    map['using'] = using;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'steps');
    final _value0 = steps;
    context?.markProperty(pointer, 'steps');
    final _lenp0 = _value0.length;
    final _evaluatedp0 = List<bool>.filled(_lenp0, false);
    for (var i = 0; i < _lenp0; i++) {
      final itemPointer = appendJsonPointer(_ptr0, i.toString());
      final item = _value0[i];
      item.validate(pointer: itemPointer, context: context);
      _evaluatedp0[i] = true;
      context?.markItem(_ptr0, i);
    }
    final _ptr1 = appendJsonPointer(pointer, 'using');
    final _value1 = using;
    context?.markProperty(pointer, 'using');
    final _actualp1 = _value1;
    if (_actualp1 != 'composite') {
      throwValidationError(
        _ptr1,
        'const',
        'Expected value equal to \'composite\' but found ' +
            _actualp1.toString() +
            '.',
      );
    }
  }
}

/// Configures the image used for the Docker action.
class RunsDocker extends Runs {
  /// An array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes the `args` to the container's `ENTRYPOINT` when the container starts up.
  /// The `args` are used in place of the `CMD` instruction in a `Dockerfile`. If you use `CMD` in your `Dockerfile`, use the guidelines ordered by preference:
  /// - Document required arguments in the action's README and omit them from the `CMD` instruction.
  /// - Use defaults that allow using the action without specifying any `args`.
  /// - If the action exposes a `--help` flag, or something similar, use that to make your action self-documenting.
  final List<String>? args;

  /// Overrides the Docker `ENTRYPOINT` in the `Dockerfile`, or sets it if one wasn't already specified. Use `entrypoint` when the `Dockerfile` does not specify an `ENTRYPOINT` or you want to override the `ENTRYPOINT` instruction. If you omit `entrypoint`, the commands you specify in the Docker `ENTRYPOINT` instruction will execute. The Docker `ENTRYPOINT instruction has a *shell* form and *exec* form. The Docker `ENTRYPOINT` documentation recommends using the *exec* form of the `ENTRYPOINT` instruction.
  final String? entrypoint;

  /// Specifies a key/value map of environment variables to set in the container environment.
  final RunsDockerEnv? env;

  /// The Docker image to use as the container to run the action. The value can be the Docker base image name, a local `Dockerfile` in your repository, or a public image in Docker Hub or another registry. To reference a `Dockerfile` local to your repository, use a path relative to your action metadata file. The `docker` application will execute this file.
  final String image;

  /// Allows you to run a cleanup script once the `runs.entrypoint` action has completed. GitHub Actions uses `docker run` to launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the main `entrypoint` container. You can access any state you need in either the workspace, `HOME`, or as a `STATE_` variable. The `post-entrypoint:` action always runs by default but you can override this using `post-if`.
  final String? postEntrypoint;
  final String? postIf;

  /// Allows you to run a script before the `entrypoint` action begins. For example, you can use `pre-entrypoint:` to run a prerequisite setup script. GitHub Actions uses `docker run` to launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the main `entrypoint` container, and any states you require must be accessed in either the workspace, `HOME`, or as a `STATE_` variable. The `pre-entrypoint:` action always runs by default but you can override this using `pre-if`.
  final String? preEntrypoint;
  final String? preIf;

  /// You must set this value to 'docker'.
  /// Constraints: const: docker
  final String using;

  const RunsDocker({
    this.args,
    this.entrypoint,
    this.env,
    required this.image,
    this.postEntrypoint,
    this.postIf,
    this.preEntrypoint,
    this.preIf,
    required this.using,
  }) : super();

  factory RunsDocker.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final args = json['args'] == null
        ? null
        : (json['args'] as List).map((e) => e as String).toList();
    remaining.remove('args');
    final entrypoint = json['entrypoint'] as String?;
    remaining.remove('entrypoint');
    final env = json['env'] == null
        ? null
        : RunsDockerEnv.fromJson((json['env'] as Map).cast<String, dynamic>());
    remaining.remove('env');
    final image = json['image'] as String;
    remaining.remove('image');
    final postEntrypoint = json['post-entrypoint'] as String?;
    remaining.remove('post-entrypoint');
    final postIf = json['post-if'] as String?;
    remaining.remove('post-if');
    final preEntrypoint = json['pre-entrypoint'] as String?;
    remaining.remove('pre-entrypoint');
    final preIf = json['pre-if'] as String?;
    remaining.remove('pre-if');
    final using = json['using'] as String;
    remaining.remove('using');
    var unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return RunsDocker(
      args: args,
      entrypoint: entrypoint,
      env: env,
      image: image,
      postEntrypoint: postEntrypoint,
      postIf: postIf,
      preEntrypoint: preEntrypoint,
      preIf: preIf,
      using: using,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (args != null) map['args'] = args;
    if (entrypoint != null) map['entrypoint'] = entrypoint;
    if (env != null) map['env'] = env!.toJson();
    map['image'] = image;
    if (postEntrypoint != null) map['post-entrypoint'] = postEntrypoint;
    if (postIf != null) map['post-if'] = postIf;
    if (preEntrypoint != null) map['pre-entrypoint'] = preEntrypoint;
    if (preIf != null) map['pre-if'] = preIf;
    map['using'] = using;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'args');
    final _value0 = args;
    if (_value0 != null) {
      context?.markProperty(pointer, 'args');
    }
    final _ptr1 = appendJsonPointer(pointer, 'entrypoint');
    final _value1 = entrypoint;
    if (_value1 != null) {
      context?.markProperty(pointer, 'entrypoint');
    }
    final _ptr2 = appendJsonPointer(pointer, 'env');
    final _value2 = env;
    if (_value2 != null) {
      context?.markProperty(pointer, 'env');
      final _jsonp2 = _value2.toJson();
      final _constraintp2c0_0 = context == null ? null : ValidationContext();
      var _constraintp2m0_0 = false;
      try {
        final context = _constraintp2c0_0;
        final _constraintp2v0_0 = RunsDockerEnvObject.fromJson(
          (_jsonp2 as Map).cast<String, dynamic>(),
        );
        _constraintp2v0_0.validate(pointer: _ptr2, context: context);
        _constraintp2m0_0 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp2c0_1 = context == null ? null : ValidationContext();
      var _constraintp2m0_1 = false;
      try {
        final context = _constraintp2c0_1;
        final _constraintp2v0_1 = _jsonp2 as String;
        _constraintp2m0_1 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp2matches0 = <bool>[
        _constraintp2m0_0,
        _constraintp2m0_1,
      ];
      final _constraintp2count0 = _constraintp2matches0
          .where((value) => value)
          .length;
      if (_constraintp2count0 != 1) {
        throwValidationError(
          _ptr2,
          'oneOf',
          'Expected exactly one subschema in #/definitions/runs-docker/properties/env/oneOf to validate.',
        );
      }
      if (context != null && _constraintp2m0_0 && _constraintp2c0_0 != null) {
        context.mergeFrom(_constraintp2c0_0!);
      }
      if (context != null && _constraintp2m0_1 && _constraintp2c0_1 != null) {
        context.mergeFrom(_constraintp2c0_1!);
      }
    }
    final _ptr3 = appendJsonPointer(pointer, 'image');
    final _value3 = image;
    context?.markProperty(pointer, 'image');
    final _ptr4 = appendJsonPointer(pointer, 'post-entrypoint');
    final _value4 = postEntrypoint;
    if (_value4 != null) {
      context?.markProperty(pointer, 'post-entrypoint');
    }
    final _ptr5 = appendJsonPointer(pointer, 'post-if');
    final _value5 = postIf;
    if (_value5 != null) {
      context?.markProperty(pointer, 'post-if');
    }
    final _ptr6 = appendJsonPointer(pointer, 'pre-entrypoint');
    final _value6 = preEntrypoint;
    if (_value6 != null) {
      context?.markProperty(pointer, 'pre-entrypoint');
    }
    final _ptr7 = appendJsonPointer(pointer, 'pre-if');
    final _value7 = preIf;
    if (_value7 != null) {
      context?.markProperty(pointer, 'pre-if');
    }
    final _ptr8 = appendJsonPointer(pointer, 'using');
    final _value8 = using;
    context?.markProperty(pointer, 'using');
    final _actualp8 = _value8;
    if (_actualp8 != 'docker') {
      throwValidationError(
        _ptr8,
        'const',
        'Expected value equal to \'docker\' but found ' +
            _actualp8.toString() +
            '.',
      );
    }
  }
}
