// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/union_types/schema.json
// Generated by json_schema2dart

import 'validation_error.dart';

/// Discriminated union using kind field
sealed class UnionTypesExampleComplexUnion {
  const UnionTypesExampleComplexUnion();

  void validate({String pointer = '', ValidationContext? context});

  factory UnionTypesExampleComplexUnion.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <UnionTypesExampleComplexUnion Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['kind'] == 'circle') {
      constMatches.add(UnionTypesExampleComplexUnionObject.fromJson);
      constMatchNames.add('UnionTypesExampleComplexUnionObject');
    }
    if (json['kind'] == 'rectangle') {
      constMatches.add(UnionTypesExampleComplexUnionObject2.fromJson);
      constMatchNames.add('UnionTypesExampleComplexUnionObject2');
    }
    if (json['kind'] == 'triangle') {
      constMatches.add(UnionTypesExampleComplexUnionObject3.fromJson);
      constMatchNames.add('UnionTypesExampleComplexUnionObject3');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError('Ambiguous UnionTypesExampleComplexUnion variant matched const heuristics: ${constMatchNames.join(', ')}');
    }
    final requiredMatches = <UnionTypesExampleComplexUnion Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('kind') && keys.contains('radius')) {
      requiredMatches.add(UnionTypesExampleComplexUnionObject.fromJson);
      requiredMatchNames.add('UnionTypesExampleComplexUnionObject');
    }
    if (keys.contains('kind') && keys.contains('width') && keys.contains('height')) {
      requiredMatches.add(UnionTypesExampleComplexUnionObject2.fromJson);
      requiredMatchNames.add('UnionTypesExampleComplexUnionObject2');
    }
    if (keys.contains('kind') && keys.contains('base') && keys.contains('height')) {
      requiredMatches.add(UnionTypesExampleComplexUnionObject3.fromJson);
      requiredMatchNames.add('UnionTypesExampleComplexUnionObject3');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError('Ambiguous UnionTypesExampleComplexUnion variant matched required-property heuristics: ${requiredMatchNames.join(', ')}');
    }
    throw ArgumentError('No UnionTypesExampleComplexUnion variant matched heuristics (keys: ${sortedKeys.join(', ')}).');
  }

  Map<String, dynamic> toJson();
}
class UnionTypesExampleComplexUnionObject extends UnionTypesExampleComplexUnion {
  /// Constraints: const: circle
  final String kind;
  final double radius;

  const UnionTypesExampleComplexUnionObject({
    required this.kind,
    required this.radius,
  }) : super();

  factory UnionTypesExampleComplexUnionObject.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final kind = json['kind'] as String;
    remaining.remove('kind');
    final radius = json['radius'] as double;
    remaining.remove('radius');
    return UnionTypesExampleComplexUnionObject(
      kind: kind,
      radius: radius,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['kind'] = kind;
    map['radius'] = radius;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'kind');
    final _value0 = kind;
    context?.markProperty(pointer, 'kind');
    final _actualp0 = _value0;
    if (_actualp0 != 'circle') {
      throwValidationError(_ptr0, 'const', 'Expected value equal to \'circle\' but found ' + _actualp0.toString() + '.');
    }
    final _ptr1 = appendJsonPointer(pointer, 'radius');
    final _value1 = radius;
    context?.markProperty(pointer, 'radius');
  }
}
class UnionTypesExampleComplexUnionObject2 extends UnionTypesExampleComplexUnion {
  final double height;
  /// Constraints: const: rectangle
  final String kind;
  final double width;

  const UnionTypesExampleComplexUnionObject2({
    required this.height,
    required this.kind,
    required this.width,
  }) : super();

  factory UnionTypesExampleComplexUnionObject2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final height = json['height'] as double;
    remaining.remove('height');
    final kind = json['kind'] as String;
    remaining.remove('kind');
    final width = json['width'] as double;
    remaining.remove('width');
    return UnionTypesExampleComplexUnionObject2(
      height: height,
      kind: kind,
      width: width,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['height'] = height;
    map['kind'] = kind;
    map['width'] = width;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'height');
    final _value0 = height;
    context?.markProperty(pointer, 'height');
    final _ptr1 = appendJsonPointer(pointer, 'kind');
    final _value1 = kind;
    context?.markProperty(pointer, 'kind');
    final _actualp1 = _value1;
    if (_actualp1 != 'rectangle') {
      throwValidationError(_ptr1, 'const', 'Expected value equal to \'rectangle\' but found ' + _actualp1.toString() + '.');
    }
    final _ptr2 = appendJsonPointer(pointer, 'width');
    final _value2 = width;
    context?.markProperty(pointer, 'width');
  }
}
class UnionTypesExampleComplexUnionObject3 extends UnionTypesExampleComplexUnion {
  final double base;
  final double height;
  /// Constraints: const: triangle
  final String kind;

  const UnionTypesExampleComplexUnionObject3({
    required this.base,
    required this.height,
    required this.kind,
  }) : super();

  factory UnionTypesExampleComplexUnionObject3.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final base = json['base'] as double;
    remaining.remove('base');
    final height = json['height'] as double;
    remaining.remove('height');
    final kind = json['kind'] as String;
    remaining.remove('kind');
    return UnionTypesExampleComplexUnionObject3(
      base: base,
      height: height,
      kind: kind,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['base'] = base;
    map['height'] = height;
    map['kind'] = kind;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'base');
    final _value0 = base;
    context?.markProperty(pointer, 'base');
    final _ptr1 = appendJsonPointer(pointer, 'height');
    final _value1 = height;
    context?.markProperty(pointer, 'height');
    final _ptr2 = appendJsonPointer(pointer, 'kind');
    final _value2 = kind;
    context?.markProperty(pointer, 'kind');
    final _actualp2 = _value2;
    if (_actualp2 != 'triangle') {
      throwValidationError(_ptr2, 'const', 'Expected value equal to \'triangle\' but found ' + _actualp2.toString() + '.');
    }
  }
}
