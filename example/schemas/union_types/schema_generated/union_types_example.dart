// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: example/schemas/union_types/schema.json
// Generated by json_schema2dart

import 'complex_union.dart';
import 'simple_union.dart';
import 'validation_error.dart';

/// Demonstrates various union type patterns
class UnionTypesExample {
  /// Discriminated union using kind field
  final ComplexUnion? complexUnion;

  /// Can be string or number
  /// Constraints: types: [string, number]
  final SimpleUnion? simpleUnion;

  const UnionTypesExample({this.complexUnion, this.simpleUnion});

  factory UnionTypesExample.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final complexUnion = json['complexUnion'] == null
        ? null
        : ComplexUnion.fromJson(
            (json['complexUnion'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('complexUnion');
    final simpleUnion = json['simpleUnion'] == null
        ? null
        : SimpleUnion.fromJson(
            (json['simpleUnion'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('simpleUnion');
    return UnionTypesExample(
      complexUnion: complexUnion,
      simpleUnion: simpleUnion,
    );
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (complexUnion != null) map['complexUnion'] = complexUnion!.toJson();
    if (simpleUnion != null) map['simpleUnion'] = simpleUnion!.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final _ptr0 = appendJsonPointer(pointer, 'complexUnion');
    final _value0 = complexUnion;
    if (_value0 != null) {
      context?.markProperty(pointer, 'complexUnion');
      final _jsonp0 = _value0.toJson();
      final _constraintp0c0_0 = context == null ? null : ValidationContext();
      var _constraintp0m0_0 = false;
      try {
        final context = _constraintp0c0_0;
        final _constraintp0v0_0 = Circle.fromJson(
          (_jsonp0 as Map).cast<String, dynamic>(),
        );
        _constraintp0v0_0.validate(pointer: _ptr0, context: context);
        _constraintp0m0_0 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0c0_1 = context == null ? null : ValidationContext();
      var _constraintp0m0_1 = false;
      try {
        final context = _constraintp0c0_1;
        final _constraintp0v0_1 = Rectangle.fromJson(
          (_jsonp0 as Map).cast<String, dynamic>(),
        );
        _constraintp0v0_1.validate(pointer: _ptr0, context: context);
        _constraintp0m0_1 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0c0_2 = context == null ? null : ValidationContext();
      var _constraintp0m0_2 = false;
      try {
        final context = _constraintp0c0_2;
        final _constraintp0v0_2 = Triangle.fromJson(
          (_jsonp0 as Map).cast<String, dynamic>(),
        );
        _constraintp0v0_2.validate(pointer: _ptr0, context: context);
        _constraintp0m0_2 = true;
      } on ValidationError {
      } catch (_) {}
      final _constraintp0matches0 = <bool>[
        _constraintp0m0_0,
        _constraintp0m0_1,
        _constraintp0m0_2,
      ];
      final _constraintp0count0 = _constraintp0matches0
          .where((value) => value)
          .length;
      if (_constraintp0count0 != 1) {
        throwValidationError(
          _ptr0,
          'oneOf',
          'Expected exactly one subschema in #/properties/complexUnion/oneOf to validate.',
        );
      }
      if (context != null && _constraintp0m0_0 && _constraintp0c0_0 != null) {
        context.mergeFrom(_constraintp0c0_0!);
      }
      if (context != null && _constraintp0m0_1 && _constraintp0c0_1 != null) {
        context.mergeFrom(_constraintp0c0_1!);
      }
      if (context != null && _constraintp0m0_2 && _constraintp0c0_2 != null) {
        context.mergeFrom(_constraintp0c0_2!);
      }
    }
    final _ptr1 = appendJsonPointer(pointer, 'simpleUnion');
    final _value1 = simpleUnion;
    if (_value1 != null) {
      context?.markProperty(pointer, 'simpleUnion');
      if (!(_value1 is String || _value1 is num)) {
        throwValidationError(
          _ptr1,
          'type',
          'Expected value to match one of the allowed types [string, number].',
        );
      }
    }
  }
}
